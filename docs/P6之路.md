目录
[TOC]

# 一、JVM篇

## 1. 类加载器

### 1.1 类加载时机

虚拟机严格规定了有且仅有5种情况必须立即对类进行“初始化”：

- (1) 使用new关键字实例化对象时 (2) 读取或设置一个类的静态字段时 (3) 调用一个类的静态方法时
- 对类进行反射调用时，如果类没有进行过初始化，需要先触发初始化
- 初始化一个类时发现父类还没有进行过初始化，必须先触发父类的初始化
- 虚拟机启动时，用户需要指定一个要执行的主类（main方法），虚拟机会先初始化这个主类
- 当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最 后的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic
  的方法句柄，并且这个 方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。

### 1.2 类加载机制

````
  类的整个生命周期包括：加载->连接->初始化
  其中连接可以分为：验证、准备、解析三个部分
  完整生命周期为 加载->验证->准备->解析->初始化
````

#### 1. 加载

````
  虚拟机需要完成以下 3 件事情: 
  1)通过一个类的全限定名来获取定义此类的二进制字节流。 
  2)将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 
  3)在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。
````

#### 2. 验证

````
  验证是连接阶段的第一步，这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。但从整体上看，验证阶段大致上会完成下面4个阶段的检验动作:
  1)文件格式验证
  2)元数据验证
  3)字节码验证
  4)符号引用验证
````

#### 3. 准备

````
  是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这个阶段中有两个容易产生混淆的概念需要强调一下，首先，这时候进行内存分配的仅包括类变量(被static修饰的变量)，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。其次，这里所说的初始值“通常情况”下 是数据类型的零值。
````

#### 4. 解析

````
  是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作不一定发生在初始化动作之前，也有可能在初始化之后。
````

#### 5. 初始化

````
  是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。在准备阶段，变量已经赋过一次系统要求的初始值， 而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达:初始化阶段是执行类构造器<clinit>()方法的过程。< clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static{} 块)中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的。 <clinit>()方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没 有对变量的赋值操作，那么编译器可以不为这个类生成<clinit>()方法。 虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁、同步，如果多个 线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。如果在一个类的<clinit >()方法中有耗时很长的操作，就可能造成多个进程阻塞。
````

#### 6. Tomcat类加载机制

````
  1) 现在本地cache查找该类是否已经被加载过，看看Tomcat有没有加载过这个类
  2) 如果Tomcat没有加载过这个类，则从系统类加载器的cache中国呢查找是否加载过
  3) 如果没有加载过这个类，尝试用ExtClassLoader类加载器类加载，重点来了，这里没有首先使用AppClassLoader来加载类。这个Tomcat的WebAppClassLoader违背了双亲委派模型，直接使用了ExtClassLoader来加载类。这里注意ExtClassLoader的双亲委派依然有效，ExtClassLoader就会使用BootstrapClassLoader来对类进行加载，保证了Jre里面的核心类不会被重复加载。比如在 Web 中加载一个 Object 类。WebAppClassLoader → ExtClassLoader → Bootstrap ClassLoader，这个加载链，就保证了 Object 不会被重复加载。
  4) 如果 BoostrapClassLoader，没有加载成功，就会调用自己的 findClass 方法由自己来对类进行加载，findClass 加载类的地址是自己本 web 应用下的 class。
  5) 加载依然失败，才使用 AppClassLoader 继续加载。
  6) 都没有加载成功的话，抛出异常。
````
````
  总结一下以上步骤，WebAppClassLoader 加载类的时候，故意打破了JVM 双亲委派机制，绕开了 AppClassLoader，直接先使用 ExtClassLoader 来加载类。
````

### 1.3 类加载器


#### 1.3.1 类与类加载器

#### 1.3.2 怎么自定义类加载器

#### 1.3.3 双亲委派模型

##### 源码解析

#### 1.3.4 打破双亲委派模型

#### 1.3.5 tomcat怎么打破双亲委派模型

## 2. 运行时数据区

### 2.1 程序计数器

````
````

### 2.2  Java虚拟机栈

````
````

### 2.3 本地方法栈

### 2.4  Java堆

#### 2.4.1 GC对象的判定方法

##### 引用计数法

````
  所谓引用计数法就是给每一个对象设置一个引用计数器，每当有一个地方引用这个对象时，就将计数器加一，引用失效时，计数器就减一。当一个对象的引用计数器为零时，说明此对象没有被引用， 也就是“死对象”,将会被垃圾回收。
  引用计数法有一个缺陷就是无法解决循环引用问题，也就是说当对象A引用对象B，对象B又引用者对象A，那么此时A、B对象的引用计数器都不为零，也就造成无法完成垃圾回收，所以主流的虚拟机都没有采用这种算法。
````

##### 可达性算法

````
  从一个被称为GC Roots的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连时，则说明此对象不可用。
````

在Java中可以作为GC Roots的对象有以下几种

- 虚拟机栈中引用的对象
- 方法区中类静态属性引用的对象
- 方法区常量池引用的对象
- 本地方法栈JNI引用的对象

##### 两次标记过程
````
  对象被回收之前，该对象的finalize()方法会被调用；两次标记，即第一次标记不在“关系网”中的对象。第二次的话就要先判断该对象有没有实现finalize()方法了，如果没有实现就直接判断该对象可回收；如果实现了就会先放在一个队列中，并由虚拟机建立的一个低优先级的线程去执行它，随后就会进行第二次的小规模标记，在这次被标记的对象就会真正的被回收了。
````

#### 2.4.2 垃圾收集算法

##### 标记-清除算法

````
  该算法分为“标记”和“清除”两个阶段。它是最基础的收集算法，后续的算法都是对其不足进行改进得到的。
  首先标记出所有需要回收的对象在标记完成后，统一回收掉所有被标记的对象。也可以反过来，标记存活的对象，统一回收掉所有未被标记的对象。

  这种算法会有两个明显的问题
  1. 效率不稳定，如果堆中包含大量对象，而且其中大部分是需要被回收的，这是必须进行大量标记和清除动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低
  2. 内存空间碎片化问题，标记-清除后会产生大量不连续的内存碎片，在需要分配较大对象时无法找到连续的足够内存而不得不提前出发另一次垃圾收集。
````

##### 标记-复制算法

````
  为了解决效率问题，标记-复制算法就出现了。他可以将内存分为大小相同的两块，每次只使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把已使用的空间一次清理掉。这样就使得每次的内存回收都是对内存区间的一半进行回收。
  但是缺陷也显而易见，这种复制算法的代价就是将可用内存缩小为了原来的一半，空间浪费太多了。并且，在对象存活率较高时就需要进行较多的复制操作，效率将会降低。
  现在的Java虚拟机都优先采用了这种收集算法回收新生代，且新生代中的对象有98%都熬不过第一轮收集。因此不需要按照1:1的比例来划分新生代的内存空间。
````

##### 标记-整理算法

````
  根据老年代的特点提出的一种标记-整理算法，标记过程仍然与”标记-清除“算法一样，但是后续步骤不是直接对可回收对象回收，而是让所有的对象向一端移动，然后直接清理掉端边界以外的内存。
  标记-清除算法和标记-整理算法的本质差异在于前者是一种非移动式的回收算法，而后者是移动式的。
````

##### 分代收集算法

````
  当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。
  比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。
````

#### 2.4.3 垃圾收集器

````
  如果说垃圾回收算法是内存回收的方法论，那么垃圾收集器就是垃圾回收的具体实现。
````

##### Serial

````
  Serial(串行)收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器。他的“单线程”的意义不仅仅意味着他只会用一条垃圾收集线程去完成垃圾收集工作，更重要的是他在进行垃圾收集工作的时候必须暂停其他工作线程，直到他收集结束。
  
  简单高效，但是Stop The World会造成不良的用户体验。
  
  可与CMS配合工作。
  
  新生代采用复制算法，老年代采用标记-整理算法。
````

##### ParNew

````
  ParNew收集器实质上就是Serial收集器的多线程并行版本，除了使用多条线程进行垃圾收集之外，其余行为都跟Serial完全一致。
  
  可与CMS配合工作。
  
  新生代采用复制算法，老年代采用标记-整理算法。
````

##### Parallel Scavenge

````
  Parallel Scavenge也是使用复制算法的多线程收集器。与ParNew相比，它更关注吞吐量（CPU利用率）。CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。
  
  JDK1.8默认使用的是Parallel Scavenge + Parallel Old，如果指定了-XX:+UseParallelGC参数，则默认指定了-XX:+UseParallelOldGC，可以使用-XX:-UseParallelOldGC来禁用该功能
  
  新生代采用复制算法，老年代采用标记-整理算法。
````

##### Serial Old

````
  Serial 收集器的老年代版本，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。
````

##### Parallel Old

````
  Parallel Scavenge 收集器的老年代版本。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。
````

##### CMS （Concurrent Mark Sweep）

````
  CMS收集器是一种以获得最短回收停顿时间为目标的收集器。关注服务的响应速度，希望系统停顿时间尽可能短，以给用户带来更好的交互体验。
  
  优点：并发收集、低停顿。
  
  缺点：
  1) 对CPU资源敏感 并发标记和并发清理阶段都是并发执行，所以会额外消耗CPU资源
  2) 无法处理浮动垃圾
  3) 使用标记-清除算法 会造成大量的内存碎片
````

从名字上可以看出CMS是基于标记-清除算法实现的，他的运作过程相可以分为四个步骤

- 初始标记

````
  初始标记仅仅是标记一下GC Roots 能直接关联到的对象，速度很快.
````

- 并发标记

````
  并发标记阶段就是从GC Roots的直接的关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。
````

- 重新标记

````
  重新标记阶段则是为了修正并发标记阶段，因用户线程继续运作而导致标记变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段长一些，但也远比并发标记阶段的时间短。
````

- 并发清除

````
  清理掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段可以与用户线程同时并发。
````

````
  其中初始标记和重新标记这两个步骤还是需要Stop The World。
````

##### G1

````
  
````

##### Shenandoah

##### ZGC

#### 2.4.4 什么时候触发GC

````
  
````

#### 2.4.5 对象漏标问题

- 三色标记

````
  
````

#### 2.4.6 内存读写屏障

#### 2.4.7 内存分配与回收策略

##### 对象优先在Eden分配

##### 大对象直接进入老年代

##### 长期存活的对象将进入老年代

##### 动态对象年龄判定

##### 空间分配担保

### 2.5 方法区

#### 常用参数

#### 方法区和永久代的关系

### class文件常量池

### 运行时常量池

### 字符串常量池

### 2.6 直接内存

## 3. 执行引擎

### 运行时栈桢结构

#### 局部变量表

````

````

#### 操作数栈

#### 动态链接

#### 方法返回地址

#### 附加信息

### 方法调用

### 动态类型语言支持

## 4. 虚拟机对象

### 对象的创建

### 对象的内存布局

### 对象的访问定位

## 5. 类文件结构

### 魔数与Class文件版本

### 常量池

### 访问标志

### 类索引、父类索引与接口索引集合

### 字段表集合

### 方法表集合

### 属性表集合

## 6. JVM常用命令

###  jps
````
   显示当前系统的java进程情况
````

- 命令格式

````
  jps [option] [hostid]
````

- option 参数
  |option|说明|
  |:--:|:---|
  |-l|  输出主类全名或jar路径|
  |-q|  只输出LVMID|
  |-m|  输出JVM启动时传递给main()的参数|
  |-v| 输出JVM启动时显式指定的JVM参数 |

### jstat
````
  监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。
````

- 命令格式
````
  jstat [option] LVMID [interval] [count]
  
  [option] : 操作参数
  LVMID : 本地虚拟机进程ID
  [interval] : 连续输出的时间间隔
  [count] : 连续输出的次数
````

- option参数
  |option|作用|
  |:--:|:---|
  |class|class loader的行为统计|
  |compiler|HotSpt JIT编译器行为统计|
  |gc|垃圾回收堆的行为统计|
  |gccapacity|各个垃圾回收代容量(young,old,perm)和他们相应的空间统计|
  |gcutil|垃圾回收统计概述|
  |gccause|垃圾收集统计概述（同-gcutil），附加最近两次垃圾回收事件的原因|
  |gcnew|新生代行为统计|
  |gcnewcapacity|新生代与其相应的内存空间的统计|
  |gcold|年老代和永生代行为统计|
  |gcoldcapacity|年老代行为统计|
  |gcpermcapacity|永生代行为统计|
  |printcompilation|HotSpot编译方法统计|

### jmap
````
  用于生成heap dump文件。也可以查询finalize执行队列、Java堆和永久代的详细信息，如当前使用率、当前使用的是哪种收集器等
````

- 命令格式
````
  jmap [option] LVMID
````

- option参数
  |option|说明|
  |:--:|:---|
  |dump|生成堆转储快照|
  |finalizerinfo|显示在F-Queue队列等待Finalizer线程执行finalizer方法的对象|
  |heap|显示Java堆详细信息|
  |histo|显示堆中对象的统计信息|
  |permstat|toprintpermanentgenerationstatistics|
  |F|当-dump没有响应时，强制生成dump快照|

### jstack
````
  jstack用于生成java虚拟机当前时刻的线程快照
````

- 命令格式
````
  jstack [option] LVMID
````

- option参数
  |option|说明|
  |:--:|:---|
  |-F|当正常输出请求不被响应时，强制输出线程堆栈|
  |-l|除堆栈外，显示关于锁的附加信息|
  |-m|如果调用到本地方法的话，可以显示C/C++的堆栈|

### jinfo
````
  实时查看和调整虚拟机运行参数
````

- 命令格式
````
  jinfo [option] [args] LVMID
````

- option参数
  |option|说明|
  |:--:|:---|
  |-flag|输出指定args参数的值|
  |-flags|不需要args参数，输出所有JVM参数的值|
  |-sysprops|输出系统属性，等同于System.getProperties()|

## 7. JVM常用参数

| 参数名称 | 含义 | 默认值 |说明|
| :--: | :--------: | :---: |:--:|
|-Xms|初始堆大小|物理内存的1/64||
|-Xmx|最大堆大小|物理内存的1/4||
|-Xmn|年轻代大小|||
|-Xss|每个线程的堆栈大小|||

```html
<div STYLE="page-break-after: always;"></div>
```

# 二、MySQL篇

## 1. 存储引擎

### 1.1 InnoDB

````
  InnoDB存储引擎支持事务，特点是行锁设计，支持外键，并支持非锁定读（读操作不会产生锁）。自从MySQL5.5.8版本开始，InnoDB存储引擎是默认的存储引擎。
  InnoDB通过多版本并发控制来获得高并发性，并且实现了SQL标准的四种隔离级别，默认为RepeatableRead 级别。同时使用一种next-keylocking的策略来避免幻读现象的产生。
  对于表中数据的存储，InnoDB采用了聚集的方式，因此每张表的存储都是按照主键的顺序进行存放。如果没有显式地在表定义时指定主键，InnoDB存储引擎会为每一行生成一个6字节的RowID，并以此作为主键。
````

### 1.2 MyISAM

````
````

## 2. 索引

### 2.1 B+树索引

### 2.2 全文索引

### 2.3 哈希索引

## 3. 锁

###          

## 4. 事务

# 三、Redis篇

# 四、MQ篇

# 五、多线程篇

# 高并发

# 分库分表篇

# Spring篇

# SpringBoot篇

# SpringCloud篇




















